## BOJ1978 - 소수 찾기  
(문제: https://www.acmicpc.net/problem/1978)  
(정답: https://www.acmicpc.net/source/20499761)  
(시간: 29분)  

### 소수 판정법  
소수의 정의는 다음과 같다.  

 > 1과 자신만을 약수로 갖는 수

이 정의를 염두에 두며 소수인지 판별하는 법을 생각해보자.  
#### 각각 판정하기  
소수의 정의를 그대로 코드로 나타낸 방법이다.  
2부터 x-1 까지 돌면서 한번도 나누어 떨어지지 않는다면 그 수는 소수이다.  
그런데 조금 더 생각해보면 굳이 x-1 까지 돌 필요가 없다. x의 약수는 sqrt(x)를 기준으로 쌍을 이루기 때문에 sqrt(x)까지 약수가 없다면 더 이상 탐색할 필요가 없다.  
##### 코드
```cpp
for(int i=2; i*i<=x; i++) {
    if(x%i==0) return 0; // 소수아님
}
return 1; // 소수
```

#### 에라토스테네스의 체  
위의 방법은 하나의 수에 대해 소수인지 판별하는 법이다.  
그런데 하나의 수가 아닌 x이하의 모든 소수를 찾으려고 할 때, 위 방법을 x번 돌리는 것 대신 다른 방법은 없을까?  
이 방법은 마치 수들을 체에 넣고 소수가 아닌 수를 걸러내는 것 같아 '에라토스테네스의 체' 라고 불린다.

각각의 수가 소수인지 정보를 담고 있는 배열 `bool isPrime[x+1]` 을 만든다. (추가로 `bool 배열`은 `1byte`를 차지하는 반면 `vector<bool>` 은 `1bit`를 사용하기에 용량도 줄이고 `cache hit rate`도 높일 수 있어 성능이 좋아진다.)  
`i=2`부터 `x`까지 돌면서 `isPrime[i]==true` 이면(`i`가 소수이면), 그 배수들을 전부 `false`로 바꿔준다. 그 과정을 거치면 `isPrime[]`에는 소수인 것들만 `true`로 남게 된다.  
그런데 이 것도 조금만 생각해보면 최적화시킬 여지가 있다. `i*2`, `i*3`, ..., `i*(i-1)` 는 이미 전에 바꿔놓았던 것이다. 따라서 `i*i` 부터 바꿔주면 된다. 그리고 또한 이에 따라 `i`도 `sqrt(x)` 까지만 돌아주면 된다(`i`가 `sqrt(x)`를 넘어가는 경우 어차피 아무 것도 바꾸지 않는다).  
##### 코드  
```cpp
vector<bool> isPrime(x + 1, true);
isPrime[1] = false;
for (int i = 2; i * i <= x; i++) {
    if (!isPrime[i]) continue;
    for (int j = i * i; j <= x; j += i) isPrime[j] = false;
}
```

#### 뭘 써야 하나?  
모든 소수를 구할 경우 에라토스테네스의 체가 더 좋은 방법이라고 생각할 수도 있다. 하지만 각각 판별하는 방법도 꽤 효율적으로 돌아간다. 시간복잡도가 크게 차이나지 않기 때문에 둘 중 아무거나 편한걸로 사용해줘도 상관없다. 단, 두 방법 모두 위에서 말한 최적화는 꼭 해주어야 한다(특히 에라토스테네스의 체는 최적화를 하지 않으면 각각 판별하는 것보다 더 느리게 돌아간다).  